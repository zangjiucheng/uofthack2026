<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robot Map + Live Controls</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 16px;
      background: #0f1115;
      color: #e6e6eb;
    }
    header { margin-bottom: 12px; display:flex; gap:16px; flex-wrap:wrap; align-items:flex-end; }
    h2 { margin: 0 12px 0 0; }
    .status { font-size: 0.9rem; margin: 2px 0; }
    .status.connected { color: #4ade80; }
    .status.disconnected { color: #f87171; }
    .timestamp { font-size: 0.75rem; opacity: 0.75; margin: 2px 0; }
    .card {
      background: #151922;
      border: 1px solid #232a3a;
      border-radius: 10px;
      padding: 12px;
    }
    .row { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    img {
      max-width: 48%;
      max-height: 70vh;
      width: auto;
      height: auto;
      object-fit: contain;
      background:#111;
      border:1px solid #333;
      border-radius: 10px;
    }
    canvas {
      width: 48%;
      min-width: 360px;
      height: 70vh;
      background: #0c0f16;
      border: 1px solid #333;
      border-radius: 10px;
      display:block;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 0.82rem;
      line-height: 1.35;
      margin: 0;
      max-height: 35vh;
      overflow:auto;
    }
    .controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    label { font-size: 0.82rem; opacity: 0.9; display:flex; gap:8px; align-items:center; }
    input[type="range"] { width: 180px; }
    .pill {
      display:inline-block; padding: 4px 8px; border-radius:999px;
      background:#0b1220; border:1px solid #22304b; font-size:0.8rem; opacity:0.95;
    }
    .hint { font-size: 0.8rem; opacity: 0.75; margin-top: 6px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:16px; margin-top:16px; }
    .tabs { display:flex; gap:8px; margin: 12px 0; flex-wrap:wrap; }
    .tab-btn { padding: 8px 12px; border: 1px solid #2a2f3a; background: #151922; color: #e6e6eb; border-radius: 6px; cursor: pointer; }
    .tab-btn.active { background: #2563eb; border-color: #2563eb; color: #fff; }
    .tab { display:none; }
    .tab.active { display:block; }
    textarea, input[type="text"] { width:100%; padding:6px; font-family:monospace; background:#0f1115; color:#e6e6eb; border:1px solid #2a2f3a; border-radius:6px; }
    button { cursor:pointer; }
    .panel { padding: 8px; background: #151922; border-radius: 6px; border:1px solid #232a3a; }
    @media (max-width: 980px) {
      img, canvas { max-width: 100%; width: 100%; }
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h2>Robot Map State Live View</h2>
      <div id="status" class="status disconnected">Disconnected</div>
      <div id="timestamp" class="timestamp">—</div>
      <div class="status" id="video-status"></div>
      <div class="status" id="pose-status"></div>
    </div>

    <div class="card controls" style="flex:1; min-width: 320px;">
      <span class="pill">Robot-centered map</span>
      <label>Map scale (px/m)
        <input id="scale" type="range" min="20" max="140" value="70" />
        <span id="scaleVal" class="pill">70</span>
      </label>
      <label>Camera FOVx (deg)
        <input id="fov" type="range" min="30" max="120" value="70" />
        <span id="fovVal" class="pill">70</span>
      </label>
      <label>Camera yaw offset (deg)
        <input id="camYaw" type="range" min="-180" max="180" value="0" />
        <span id="camYawVal" class="pill">0</span>
      </label>
      <div class="hint">
        Fake robot pose controls (for testing): <span class="pill">W/A/S/D</span> move, <span class="pill">Q/E</span> rotate robot,
        <span class="pill">←/→</span> rotate camera.
      </div>
    </div>
  </header>

  <div class="tabs">
    <button class="tab-btn active" data-tab="map">Map + Detic</button>
    <button class="tab-btn" data-tab="state">State</button>
    <button class="tab-btn" data-tab="visual">Visual</button>
    <button class="tab-btn" data-tab="controller">Controller</button>
    <button class="tab-btn" data-tab="commands">Commands</button>
    <button class="tab-btn" data-tab="enroll">Face ID</button>
    <button class="tab-btn" data-tab="tasks">Tasks</button>
  </div>

  <div id="tab-map" class="tab active">
    <div class="row">
      <img id="video" />
      <canvas id="map"></canvas>
    </div>

    <div class="grid">
      <div class="card">
        <div class="pill">Raw state (merged)</div>
        <pre id="output">{}</pre>
      </div>
      <div class="card">
        <div class="pill">Detections interpreted (no history; latest only)</div>
        <pre id="detOut">[]</pre>
      </div>
    </div>
  </div>

  <div id="tab-state" class="tab">
    <div class="card">
      <div class="pill">Raw state</div>
      <pre id="output-state">{}</pre>
    </div>
  </div>

  <div id="tab-visual" class="tab">
    <div class="card">
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
        <button id="toggle-visual" style="padding:6px 10px; background:#2563eb; color:white; border:none; border-radius:4px;">Pause visual</button>
        <span id="visual-status" style="font-size:0.85rem; color:#9ca3af;">live</span>
      </div>
      <pre id="output-visual">{}</pre>
    </div>
  </div>

  <div id="tab-controller" class="tab">
    <div class="card">
      <div class="pill">Controller</div>
      <pre id="output-controller">{}</pre>
    </div>
  </div>

  <div id="tab-commands" class="tab">
    <div class="card panel">
      <div style="margin-bottom:6px;">Set Tracking ROI (bbox array)</div>
      <textarea id="roi-bbox" rows="3" placeholder='[x1, y1, x2, y2]'></textarea>
      <button id="roi-send" style="margin-top:6px; padding:8px 12px; background:#2563eb; color:white; border:none; border-radius:4px;">Send ROI</button>
      <button id="roi-stop" style="margin-top:6px; padding:8px 12px; background:#ef4444; color:white; border:none; border-radius:4px;">Stop Tracking</button>
      <div id="roi-status" style="font-size:0.85rem; margin-top:6px; color:#9ca3af;"></div>
    </div>
    <div class="card panel" style="margin-top:12px;">
      <div class="pill">Detic controls</div>
      <div style="margin-top:8px;">Object list (comma-separated; empty uses built-in vocab)</div>
      <input id="detic-objects" type="text" placeholder="person, bottle, chair" style="margin-top:4px;" />
      <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
        <label style="flex:1; min-width:160px;">Vocabulary
          <input id="detic-vocab" type="text" value="lvis" style="margin-top:4px;" />
        </label>
        <label style="flex:1; min-width:160px;">Score threshold
          <input id="detic-threshold" type="text" value="0.3" style="margin-top:4px;" />
        </label>
      </div>
      <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
        <button id="detic-update" style="padding:8px 12px; background:#2563eb; color:white; border:none; border-radius:4px;">Update objects</button>
        <button id="detic-trigger" style="padding:8px 12px; background:#22c55e; color:white; border:none; border-radius:4px;">Run once</button>
      </div>
      <div id="detic-status" style="font-size:0.85rem; margin-top:6px; color:#9ca3af;"></div>
      <div style="margin-top:10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <button id="detic-list" style="padding:8px 12px; background:#6b7280; color:white; border:none; border-radius:4px;">List Detic labels</button>
        <pre id="detic-list-out" style="flex:1; min-height:60px; max-height:200px; margin:0; font-size:0.8rem;">[]</pre>
      </div>
    </div>
  </div>

  <div id="tab-tasks" class="tab">
    <div class="card panel">
      <div class="pill">Task enqueue (pi)</div>
      <div style="margin-top:8px;">Approach object</div>
      <input id="approach-object" type="text" placeholder="object name" style="margin-top:4px;" />
      <button id="approach-object-btn" style="margin-top:6px; padding:8px 12px; background:#2563eb; color:white; border:none; border-radius:4px;">Send approach_object</button>
      <div style="margin-top:12px;">Approach person</div>
      <input id="approach-person" type="text" placeholder="person name" style="margin-top:4px;" />
      <button id="approach-person-btn" style="margin-top:6px; padding:8px 12px; background:#22c55e; color:white; border:none; border-radius:4px;">Send approach_person</button>
      <div id="task-status" style="font-size:0.85rem; margin-top:8px; color:#9ca3af;"></div>
    </div>
  </div>

  <div id="tab-enroll" class="tab">
    <div class="card panel">
      <div style="margin-bottom:6px;">Enroll face</div>
      <input id="face-name" type="text" placeholder="Name" style="margin-top:4px;" />
      <button id="face-enroll" style="margin-top:6px; padding:8px 12px; background:#22c55e; color:white; border:none; border-radius:4px;">Enroll Face</button>
      <div style="margin-top:12px; border-top:1px solid #232a3a; padding-top:10px;">
        <div style="margin-bottom:6px;">Re-record / update existing face</div>
        <input id="face-id" type="text" placeholder="ID" style="margin-top:4px;" />
        <input id="face-update-name" type="text" placeholder="Optional new name" style="margin-top:4px;" />
        <button id="face-update" style="margin-top:6px; padding:8px 12px; background:#2563eb; color:white; border:none; border-radius:4px;">Update Face</button>
        <button id="face-delete" style="margin-top:6px; margin-left:6px; padding:8px 12px; background:#ef4444; color:white; border:none; border-radius:4px;">Delete Face</button>
      </div>
      <button id="face-reset" style="margin-top:6px; padding:8px 12px; background:#ef4444; color:white; border:none; border-radius:4px;">Reset Face DB</button>
      <div style="margin-top:10px; display:flex; gap:10px; align-items:center;">
        <button id="face-list" style="padding:8px 12px; background:#6b7280; color:white; border:none; border-radius:4px;">List Faces</button>
        <pre id="face-list-out" style="flex:1; min-height:60px; max-height:200px; margin:0; font-size:0.8rem;">[]</pre>
      </div>
      <div id="enroll-status" style="font-size:0.85rem; margin-top:6px; color:#9ca3af;"></div>
      <div id="enroll-video-wrap" style="margin-top:10px;">
        <img id="enroll-video" />
      </div>
    </div>
  </div>

  <script>
    // ----------------------------
    // Connection params
    // ----------------------------
    const params = new URLSearchParams(window.location.search);
    const defaultHost = window.location.hostname || "localhost";
    const WS_URL = params.get("ws") || `ws://${defaultHost}:8765`;
    const VIDEO_WS_URL = params.get("video_ws") || `ws://${defaultHost}:8890`;
    const CMD_POST_URL = params.get("cmd_post") || `http://${defaultHost}:8080/set_tracking_roi`;
    const BACKEND_REST_URL = params.get("rest") || `http://${defaultHost}:8080`;
    const FACE_ONLY_URL = `http://${defaultHost}:8080/set_face_only`;

    // ----------------------------
    // Elements
    // ----------------------------
    const statusEl = document.getElementById("status");
    const videoStatusEl = document.getElementById("video-status");
    const poseStatusEl = document.getElementById("pose-status");
    const outputEl = document.getElementById("output");
    const outputStateEl = document.getElementById("output-state");
    const outputVisualEl = document.getElementById("output-visual");
    const outputControllerEl = document.getElementById("output-controller");
    const detOutEl = document.getElementById("detOut");
    const timestampEl = document.getElementById("timestamp");
    const videoEl = document.getElementById("video");
    const enrollVideoEl = document.getElementById("enroll-video");
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d");

    const scaleSlider = document.getElementById("scale");
    const scaleVal = document.getElementById("scaleVal");
    const fovSlider = document.getElementById("fov");
    const fovVal = document.getElementById("fovVal");
    const camYawSlider = document.getElementById("camYaw");
    const camYawVal = document.getElementById("camYawVal");

    const toggleVisualBtn = document.getElementById("toggle-visual");
    const visualStatus = document.getElementById("visual-status");

    const roiBox = document.getElementById("roi-bbox");
    const roiSendBtn = document.getElementById("roi-send");
    const stopBtn = document.getElementById("roi-stop");
    const roiStatus = document.getElementById("roi-status");
    const faceNameInput = document.getElementById("face-name");
    const faceIdInput = document.getElementById("face-id");
    const faceUpdateNameInput = document.getElementById("face-update-name");
    const faceEnrollBtn = document.getElementById("face-enroll");
    const faceUpdateBtn = document.getElementById("face-update");
    const faceDeleteBtn = document.getElementById("face-delete");
    const faceResetBtn = document.getElementById("face-reset");
    const faceListBtn = document.getElementById("face-list");
    const faceListOut = document.getElementById("face-list-out");
    const enrollStatus = document.getElementById("enroll-status");

    const tabButtons = document.querySelectorAll(".tab-btn");
    const tabs = document.querySelectorAll(".tab");
    const approachObjectInput = document.getElementById("approach-object");
    const approachPersonInput = document.getElementById("approach-person");
    const approachObjectBtn = document.getElementById("approach-object-btn");
    const approachPersonBtn = document.getElementById("approach-person-btn");
    const taskStatus = document.getElementById("task-status");
    const deticObjectsInput = document.getElementById("detic-objects");
    const deticVocabInput = document.getElementById("detic-vocab");
    const deticThreshInput = document.getElementById("detic-threshold");
    const deticUpdateBtn = document.getElementById("detic-update");
    const deticTriggerBtn = document.getElementById("detic-trigger");
    const deticStatus = document.getElementById("detic-status");
    const deticListBtn = document.getElementById("detic-list");
    const deticListOut = document.getElementById("detic-list-out");

    // ----------------------------
    // State (robot pose can be "real" from backend OR faked locally)
    // ----------------------------
    const ui = {
      pxPerM: Number(scaleSlider.value),
      fovXDeg: Number(fovSlider.value),
      camYawDeg: Number(camYawSlider.value),
    };

    // If backend doesn't provide robot pose yet, we fake it.
    // Absolute pose (meters, radians). Map drawing is always robot-centered.
    const fake = {
      enabled: true, // automatically disabled if backend provides pose
      x: 0,
      y: 0,
      yaw: 0, // robot heading in world frame
      stepM: 0.15,
      stepYaw: (8 * Math.PI / 180),
      camYawStepDeg: 6,
    };

    // Latest backend payload
    let latest = {
      ts: null,
      state: {},
      visual: {},
      controller: {},
      imgW: 640,
      imgH: 480
    };

    let visualPaused = false;

    // ----------------------------
    // Helpers: parsing payload shapes
    // ----------------------------
    function pickRobotPose(state) {
      // Try a few likely shapes (adjust later if your backend differs):
      // state.robot = {x,y,yaw} or state.pose = {x,y,yaw} or state.camera_pose...
      const candidates = [
        state?.robot,
        state?.pose,
        state?.robot_pose,
        state?.camera,
        state?.camera_pose,
      ].filter(Boolean);

      for (const c of candidates) {
        const x = c.x ?? c.pos_x ?? c.px;
        const y = c.y ?? c.pos_y ?? c.py;
        const yaw = c.yaw ?? c.theta ?? c.heading;
        if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(yaw)) {
          return { x: Number(x), y: Number(y), yaw: Number(yaw), source: "backend" };
        }
      }
      return null;
    }

    function pickDetections(state) {
        const dets =
            state?.detic?.detections ??
            state?.visual?.detic?.detections ??
            state?.detections ??
            state?.objects ??
            state?.items ??
            state?.track?.detections; // optional guess

        return Array.isArray(dets) ? dets : [];
    }

    function getLabel(det) {
      return det.label ?? det.class_name ?? det.name ?? det.category ?? "object";
    }

    function getConf(det) {
      const c = det.conf ?? det.score ?? det.confidence;
      return Number.isFinite(c) ? Number(c) : null;
    }

    function getBbox(det) {
      // bbox could be {x1,y1,x2,y2} or [x1,y1,x2,y2]
      if (Array.isArray(det.bbox) && det.bbox.length >= 4) return det.bbox.slice(0,4).map(Number);
      if (Array.isArray(det.box) && det.box.length >= 4) return det.box.slice(0,4).map(Number);
      if (det.bbox && typeof det.bbox === "object") {
        const {x1,y1,x2,y2} = det.bbox;
        if ([x1,y1,x2,y2].every(Number.isFinite)) return [x1,y1,x2,y2].map(Number);
      }
      return null;
    }

    function getXY(det) {
      // Some backends already compute map positions per object: det.x, det.y
      const x = det.x ?? det.map_x ?? det.world_x;
      const y = det.y ?? det.map_y ?? det.world_y;
      if (Number.isFinite(x) && Number.isFinite(y)) return {x:Number(x), y:Number(y)};
      return null;
    }

    // ----------------------------
    // Distance estimation from bbox (no depth sensor)
    // Heuristic: larger bbox height ratio => closer.
    // We only output buckets as you requested.
    // ----------------------------
    function distanceBucketFromBbox(bbox, imgH) {
      const h = Math.max(1, Number(bbox[3]) - Number(bbox[1]));

      const r = h / Math.max(1, imgH); // height ratio
      // tuned for "feel", not accuracy
      if (r > 0.45) return { bucket: "very close", approxM: 0.6 };
      if (r > 0.28) return { bucket: "close",      approxM: 1.2 };
      if (r > 0.16) return { bucket: "a lil far",  approxM: 2.4 };
      if (r > 0.08) return { bucket: "far",        approxM: 4.5 };
      return            { bucket: "very far",  approxM: 7.5 };
    }

    // Bearing from bbox center:
    // Option A (simple): map pixel offset to FOV
    // angle=0 means image center; left positive
    function bearingRadFromBbox(bbox, imgW, fovXDeg) {
      const cx = 0.5 * (bbox[0] + bbox[2]);
      const norm = (cx - imgW/2) / (imgW/2); // [-1,1]
      const halfFovRad = (fovXDeg * Math.PI / 180) / 2;
      return norm * halfFovRad;
    }

    // Convert object relative polar to robot-frame (forward, left)
    function polarToRobotFrame(rangeM, bearingRad) {
      const forward = rangeM * Math.cos(bearingRad);
      const left = rangeM * Math.sin(bearingRad);
      return { forward, left };
    }

    // If you have absolute item coords + absolute robot pose, convert to robot frame
    function worldToRobotFrame(itemXY, robotPose) {
      const dx = itemXY.x - robotPose.x;
      const dy = itemXY.y - robotPose.y;
      // rotate by -yaw
      const c = Math.cos(-robotPose.yaw);
      const s = Math.sin(-robotPose.yaw);
      const rx = dx * c - dy * s;
      const ry = dx * s + dy * c;
      // interpret robot frame: forward = rx, left = ry (convention)
      return { forward: rx, left: ry };
    }

    // ----------------------------
    // Drawing
    // ----------------------------
    function resizeCanvasToCSSPixels() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);
    }

    function drawMap(robotPose, interpreted) {
      resizeCanvasToCSSPixels();
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;

      // background
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = "#0c0f16";
      ctx.fillRect(0,0,W,H);

      const cx = W/2, cy = H/2;
      const pxPerM = ui.pxPerM;

      // grid rings
      ctx.strokeStyle = "rgba(120,140,180,0.18)";
      ctx.lineWidth = 1;
      for (let m=1; m<=8; m++) {
        const r = m * pxPerM;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.stroke();
      }

      // crosshair axes (robot-centered)
      ctx.strokeStyle = "rgba(120,140,180,0.22)";
      ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, H); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(W, cy); ctx.stroke();

      // robot icon at center
      ctx.fillStyle = "rgba(74, 222, 128, 0.95)";
      ctx.beginPath();
      ctx.arc(cx, cy, 7, 0, Math.PI*2);
      ctx.fill();

      // heading arrow (robot yaw) + camera yaw offset
      const heading = robotPose.yaw + (ui.camYawDeg * Math.PI/180);
      const arrowLen = 34;
      const hx = cx + arrowLen * Math.sin(heading);   // left-positive -> canvas x right
      const hy = cy - arrowLen * Math.cos(heading);   // forward-positive -> canvas up
      ctx.strokeStyle = "rgba(74, 222, 128, 0.9)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(hx, hy);
      ctx.stroke();

      // FOV cone (approx)
      const halfFov = (ui.fovXDeg * Math.PI/180)/2;
      ctx.strokeStyle = "rgba(99, 164, 255, 0.25)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + 140*Math.sin(heading - halfFov), cy - 140*Math.cos(heading - halfFov));
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + 140*Math.sin(heading + halfFov), cy - 140*Math.cos(heading + halfFov));
      ctx.stroke();

      // plot detections
      for (const d of interpreted) {
        const x = cx + d.left * pxPerM;
        const y = cy - d.forward * pxPerM;

        // point
        ctx.fillStyle = "rgba(99, 164, 255, 0.95)";
        ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI*2); ctx.fill();

        // label
        ctx.font = "12px system-ui, -apple-system, sans-serif";
        ctx.fillStyle = "rgba(230,230,235,0.95)";
        const text = `${d.label} · ${d.distance.bucket}`;
        ctx.fillText(text, x + 10, y - 10);
      }
    }

    // ----------------------------
    // Interpret detections into robot frame (forward, left)
    // No memory: uses only latest message
    // ----------------------------
    function interpretDetections(state, robotPose) {
      const dets = pickDetections(state);

      // If backend provides img size somewhere, use it; else keep defaults
      const imgW = state?.img_w ?? state?.image_w ?? state?.width ?? latest.imgW;
      const imgH = state?.img_h ?? state?.image_h ?? state?.height ?? latest.imgH;

      const out = [];

      for (const det of dets) {
        const label = getLabel(det);
        const conf = getConf(det);

        const xy = getXY(det);
        const bbox = getBbox(det);

        let forward = null, left = null, distance = null, bearingRad = null;

        if (xy && Number.isFinite(robotPose?.x) && Number.isFinite(robotPose?.y)) {
          // Case 1: backend already gives absolute coords for items
          const rf = worldToRobotFrame(xy, robotPose);
          forward = rf.forward;
          left = rf.left;
          const range = Math.hypot(forward, left);
          distance = { bucket: (range<1?"very close":range<2?"close":range<4?"a lil far":range<7?"far":"very far"), approxM: range };
          bearingRad = Math.atan2(left, forward);
        } else if (bbox) {
          // Case 2: only bbox available (Detic). Estimate bearing + distance bucket.
          bearingRad = bearingRadFromBbox(bbox, imgW, ui.fovXDeg);
          distance = distanceBucketFromBbox(bbox, imgH);

          // include camera yaw offset here so map rotates correctly with camera pan
          const bearingWithCam = bearingRad + (ui.camYawDeg * Math.PI/180);

          const rf = polarToRobotFrame(distance.approxM, bearingWithCam);
          forward = rf.forward;
          left = rf.left;
        } else {
          // Can't place it on map (no bbox, no xy)
          continue;
        }

        out.push({
          label,
          conf,
          forward,
          left,
          bearingDeg: bearingRad == null ? null : (bearingRad * 180/Math.PI),
          distance,
          raw: det
        });
      }

      return out;
    }

    // ----------------------------
    // Tabs + face-only toggle
    // ----------------------------
    async function toggleFaceOnly(enabled) {
      try {
        await fetch(FACE_ONLY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ enabled }),
        });
      } catch (err) {
        console.warn("face-only toggle failed", err);
      }
    }

    function showTab(name) {
      tabButtons.forEach((btn) => {
        const active = btn.dataset.tab === name;
        btn.classList.toggle("active", active);
      });
      tabs.forEach((tab) => {
        tab.classList.toggle("active", tab.id === `tab-${name}`);
      });
      toggleFaceOnly(name === "enroll");
    }

    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => showTab(btn.dataset.tab));
    });

    // ----------------------------
    // WebSockets
    // ----------------------------
    function connectVideo() {
      const vws = new WebSocket(VIDEO_WS_URL);
      vws.binaryType = "arraybuffer";

      vws.onopen = () => {
        videoStatusEl.textContent = "Video WS: " + VIDEO_WS_URL;
        videoStatusEl.className = "status connected";
      };

      vws.onclose = () => {
        videoStatusEl.textContent = "Video WS: reconnecting...";
        videoStatusEl.className = "status disconnected";
        setTimeout(connectVideo, 1000);
      };

      vws.onerror = () => vws.close();

      vws.onmessage = (event) => {
        const blob = new Blob([event.data], { type: "image/jpeg" });
        const url = URL.createObjectURL(blob);
        const targets = [videoEl];
        if (enrollVideoEl) targets.push(enrollVideoEl);

        let remaining = targets.length;
        const cleanup = () => {
          remaining -= 1;
          if (remaining <= 0) URL.revokeObjectURL(url);
        };

        targets.forEach((el) => {
          el.onload = () => {
            if (el === videoEl) {
              latest.imgW = videoEl.naturalWidth || latest.imgW;
              latest.imgH = videoEl.naturalHeight || latest.imgH;
            }
            cleanup();
          };
          el.src = url;
        });
      };
    }

    function connectState() {
      const ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        statusEl.textContent = "Connected";
        statusEl.className = "status connected";
      };

      ws.onclose = () => {
        statusEl.textContent = "Disconnected (retrying...)";
        statusEl.className = "status disconnected";
        setTimeout(connectState, 1000);
      };

      ws.onerror = () => ws.close();

      ws.onmessage = (event) => {
        try {
            const payload = JSON.parse(event.data);

            const state = payload.state ?? {};
            const visual = payload.visual ?? {};
            const controller = payload.controller ?? {};

            // Merge visual into state (frontend-side, so it works even if backend doesn’t merge)
            const merged = (state && typeof state === "object") ? { ...state } : {};
            if (visual && typeof visual === "object") Object.assign(merged, visual);

            latest.ts = payload.ts ?? payload.timestamp ?? null;
            latest.state = merged;
            latest.visual = visual || {};
            latest.controller = controller || {};

            if (typeof latest.ts === "number") {
              timestampEl.textContent = "Server time: " + latest.ts.toFixed(3);
            } else {
              timestampEl.textContent = "Server time: —";
            }

            // Print merged state so you can SEE detic/track/face if they exist
            outputEl.textContent = JSON.stringify(merged, null, 2);
            if (outputStateEl) outputStateEl.textContent = JSON.stringify(state, null, 2);
            if (outputControllerEl) outputControllerEl.textContent = "controller:\n" + JSON.stringify(controller || {}, null, 2);
            if (!visualPaused && outputVisualEl) outputVisualEl.textContent = "visual:\n" + JSON.stringify(visual || {}, null, 2);

            const backendPose = pickRobotPose(merged);
            let pose;
            if (backendPose) {
              fake.enabled = false;
              pose = { x: backendPose.x, y: backendPose.y, yaw: backendPose.yaw };
            } else {
              fake.enabled = true;
              pose = { x: fake.x, y: fake.y, yaw: fake.yaw };
            }

            poseStatusEl.textContent =
              `Robot pose (${fake.enabled ? "FAKE" : "backend"}): x=${pose.x.toFixed(2)}m, y=${pose.y.toFixed(2)}m, yaw=${(pose.yaw*180/Math.PI).toFixed(1)}°`;
            poseStatusEl.className = "status " + (fake.enabled ? "disconnected" : "connected");

            const interpreted = interpretDetections(merged, pose);

            detOutEl.textContent = JSON.stringify(interpreted.map(d => ({
              label: d.label,
              conf: d.conf,
              forward_m: Number(d.forward?.toFixed?.(2) ?? d.forward),
              left_m: Number(d.left?.toFixed?.(2) ?? d.left),
              distance: d.distance?.bucket,
            })), null, 2);

            drawMap(pose, interpreted);

        } catch (err) {
            console.error("Invalid message:", err);
        }
      };

    }

    // ----------------------------
    // UI controls
    // ----------------------------
    function syncUI() {
      ui.pxPerM = Number(scaleSlider.value);
      ui.fovXDeg = Number(fovSlider.value);
      ui.camYawDeg = Number(camYawSlider.value);
      scaleVal.textContent = String(ui.pxPerM);
      fovVal.textContent = String(ui.fovXDeg);
      camYawVal.textContent = String(ui.camYawDeg);
    }

    scaleSlider.addEventListener("input", syncUI);
    fovSlider.addEventListener("input", syncUI);
    camYawSlider.addEventListener("input", syncUI);

    window.addEventListener("resize", () => {
      // redraw using latest known info (if any)
      const pose = fake.enabled ? {x:fake.x, y:fake.y, yaw:fake.yaw} : (pickRobotPose(latest.state) ?? {x:0,y:0,yaw:0});
      const interpreted = interpretDetections(latest.state, pose);
      drawMap(pose, interpreted);
    });

    // Keyboard controls for faking robot pose / camera yaw
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();

      // camera yaw with arrows
      if (e.key === "ArrowLeft") { camYawSlider.value = String(Number(camYawSlider.value) - fake.camYawStepDeg); syncUI(); return; }
      if (e.key === "ArrowRight"){ camYawSlider.value = String(Number(camYawSlider.value) + fake.camYawStepDeg); syncUI(); return; }

      // only move fake pose if backend pose not provided
      if (!fake.enabled) return;

      if (k === "q") fake.yaw -= fake.stepYaw;
      if (k === "e") fake.yaw += fake.stepYaw;

      // move in robot heading frame
      const c = Math.cos(fake.yaw);
      const s = Math.sin(fake.yaw);

      if (k === "w") { fake.x += fake.stepM * c; fake.y += fake.stepM * s; }
      if (k === "s") { fake.x -= fake.stepM * c; fake.y -= fake.stepM * s; }
      if (k === "a") { fake.x += fake.stepM * (-s); fake.y += fake.stepM * (c); }
      if (k === "d") { fake.x -= fake.stepM * (-s); fake.y -= fake.stepM * (c); }

      // redraw
      const pose = {x:fake.x, y:fake.y, yaw:fake.yaw};
      const interpreted = interpretDetections(latest.state, pose);
      drawMap(pose, interpreted);
      poseStatusEl.textContent =
        `Robot pose (FAKE): x=${pose.x.toFixed(2)}m, y=${pose.y.toFixed(2)}m, yaw=${(pose.yaw*180/Math.PI).toFixed(1)}°`;
    });

    // Visual tab pause/resume
    toggleVisualBtn.onclick = () => {
      visualPaused = !visualPaused;
      toggleVisualBtn.textContent = visualPaused ? "Resume visual" : "Pause visual";
      visualStatus.textContent = visualPaused ? "paused (copy safely)" : "live";
      visualStatus.style.color = visualPaused ? "#fbbf24" : "#9ca3af";
      if (!visualPaused && outputVisualEl) {
        outputVisualEl.textContent = "visual:\n" + JSON.stringify(latest.visual || {}, null, 2);
      }
    };

    // ROI + face commands
    function sendCommand() {
      roiSendBtn.onclick = async () => {
        let bbox;
        try {
          bbox = JSON.parse(roiBox.value);
        } catch {
          roiStatus.textContent = "Enter bbox JSON like [x1,y1,x2,y2]";
          roiStatus.style.color = "#f87171";
          return;
        }
        if (!Array.isArray(bbox) || bbox.length !== 4 || bbox.some((v) => typeof v !== "number")) {
          roiStatus.textContent = "bbox must be [x1,y1,x2,y2]";
          roiStatus.style.color = "#f87171";
          return;
        }
        roiStatus.textContent = "Sending...";
        roiStatus.style.color = "#9ca3af";
        try {
          const res = await fetch(CMD_POST_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ bbox }),
          });
          const data = await res.json();
          roiStatus.textContent = "Response: " + JSON.stringify(data);
          roiStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
        } catch (err) {
          roiStatus.textContent = "Error: " + err;
          roiStatus.style.color = "#f87171";
        }
      };

      faceEnrollBtn.onclick = async () => {
        const name = faceNameInput.value.trim();
        if (!name) {
          enrollStatus.textContent = "Enter a name to enroll";
          enrollStatus.style.color = "#f87171";
          return;
        }
        enrollStatus.textContent = "Sending face enroll...";
        enrollStatus.style.color = "#9ca3af";
        try {
          const res = await fetch(`http://${defaultHost}:8080/start_face_record`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name }),
          });
          const data = await res.json();
          enrollStatus.textContent = "Response: " + JSON.stringify(data);
          enrollStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
        } catch (err) {
          enrollStatus.textContent = "Error: " + err;
          enrollStatus.style.color = "#f87171";
        }
      };

      faceResetBtn.onclick = async () => {
        enrollStatus.textContent = "Resetting face DB...";
        enrollStatus.style.color = "#9ca3af";
        try {
          const res = await fetch(`http://${defaultHost}:8080/reset_face_db`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: "{}",
          });
          const data = await res.json();
          enrollStatus.textContent = "Response: " + JSON.stringify(data);
          enrollStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
        } catch (err) {
          enrollStatus.textContent = "Error: " + err;
          enrollStatus.style.color = "#f87171";
        }
      };

      faceUpdateBtn.onclick = async () => {
        const idVal = Number(faceIdInput.value);
        if (!Number.isFinite(idVal)) {
          enrollStatus.textContent = "Enter a numeric ID to update";
          enrollStatus.style.color = "#f87171";
          return;
        }
        const name = faceUpdateNameInput.value.trim();
        enrollStatus.textContent = "Sending face update...";
        enrollStatus.style.color = "#9ca3af";
        const payload = name ? { id: idVal, name } : { id: idVal };
        try {
          const res = await fetch(`http://${defaultHost}:8080/update_face_record`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const data = await res.json();
          enrollStatus.textContent = "Response: " + JSON.stringify(data);
          enrollStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
        } catch (err) {
          enrollStatus.textContent = "Error: " + err;
          enrollStatus.style.color = "#f87171";
        }
      };

      faceDeleteBtn.onclick = async () => {
        const idVal = Number(faceIdInput.value);
        if (!Number.isFinite(idVal)) {
          enrollStatus.textContent = "Enter a numeric ID to delete";
          enrollStatus.style.color = "#f87171";
          return;
        }
        enrollStatus.textContent = `Deleting face ${idVal}...`;
        enrollStatus.style.color = "#9ca3af";
        try {
          const res = await fetch(`http://${defaultHost}:8080/delete_face`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ id: idVal }),
          });
          const data = await res.json();
          enrollStatus.textContent = "Response: " + JSON.stringify(data);
          enrollStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
        } catch (err) {
          enrollStatus.textContent = "Error: " + err;
          enrollStatus.style.color = "#f87171";
        }
      };

      faceListBtn.onclick = async () => {
        enrollStatus.textContent = "Loading faces...";
        enrollStatus.style.color = "#9ca3af";
        try {
          const res = await fetch(`http://${defaultHost}:8080/list_faces`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: "{}",
          });
          const data = await res.json();
          if (faceListOut) {
            faceListOut.textContent = JSON.stringify(data.faces ?? data, null, 2);
          }
          enrollStatus.textContent = "Response: " + JSON.stringify(data);
          enrollStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
        } catch (err) {
          enrollStatus.textContent = "Error: " + err;
          enrollStatus.style.color = "#f87171";
        }
      };

      if (approachObjectBtn && approachObjectInput && taskStatus) {
        approachObjectBtn.onclick = async () => {
          const obj = approachObjectInput.value.trim();
          if (!obj) {
            taskStatus.textContent = "Enter object name";
            taskStatus.style.color = "#f87171";
            return;
          }
          taskStatus.textContent = "Sending approach_object...";
          taskStatus.style.color = "#9ca3af";
          try {
            const res = await fetch(`${BACKEND_REST_URL}/approach_object`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ object: obj }),
            });
            const data = await res.json();
            taskStatus.textContent = "Response: " + JSON.stringify(data);
            taskStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
          } catch (err) {
            taskStatus.textContent = "Error: " + err;
            taskStatus.style.color = "#f87171";
          }
        };
      }

      if (approachPersonBtn && approachPersonInput && taskStatus) {
        approachPersonBtn.onclick = async () => {
          const person = approachPersonInput.value.trim();
          if (!person) {
            taskStatus.textContent = "Enter person name";
            taskStatus.style.color = "#f87171";
            return;
          }
          taskStatus.textContent = "Sending approach_person...";
          taskStatus.style.color = "#9ca3af";
          try {
            const res = await fetch(`${BACKEND_REST_URL}/approach_person`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ name: person }),
            });
            const data = await res.json();
            taskStatus.textContent = "Response: " + JSON.stringify(data);
            taskStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
          } catch (err) {
            taskStatus.textContent = "Error: " + err;
            taskStatus.style.color = "#f87171";
          }
        };
      }

      stopBtn.onclick = async () => {
        roiStatus.textContent = "Sending stop...";
        roiStatus.style.color = "#9ca3af";
        try {
          const res = await fetch(`http://${defaultHost}:8080/stop_tracking`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: "{}",
          });
          const data = await res.json();
          roiStatus.textContent = "Response: " + JSON.stringify(data);
          roiStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
        } catch (err) {
          roiStatus.textContent = "Error: " + err;
          roiStatus.style.color = "#f87171";
        }
      };

      if (deticUpdateBtn && deticObjectsInput && deticVocabInput && deticThreshInput && deticStatus) {
        deticUpdateBtn.onclick = async () => {
          const raw = deticObjectsInput.value.trim();
          const vocabulary = deticVocabInput.value.trim() || "lvis";
          const parts = raw ? raw.split(",").map((p) => p.trim()).filter(Boolean) : [];
          const payload = {
            object_list: parts.length > 0 ? parts : null,
            vocabulary,
          };
          const thr = Number(deticThreshInput.value);
          if (Number.isFinite(thr)) payload.score_threshold = thr;
          deticStatus.textContent = "Updating Detic objects...";
          deticStatus.style.color = "#9ca3af";
          try {
            const res = await fetch(`${BACKEND_REST_URL}/update_detic_objects`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            const data = await res.json();
            deticStatus.textContent = "Response: " + JSON.stringify(data);
            deticStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
          } catch (err) {
            deticStatus.textContent = "Error: " + err;
            deticStatus.style.color = "#f87171";
          }
        };
      }

      if (deticTriggerBtn && deticStatus) {
        deticTriggerBtn.onclick = async () => {
          deticStatus.textContent = "Triggering Detic...";
          deticStatus.style.color = "#9ca3af";
          try {
            const res = await fetch(`${BACKEND_REST_URL}/trigger_detic`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: "{}",
            });
            const data = await res.json();
            deticStatus.textContent = "Response: " + JSON.stringify(data);
            deticStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
          } catch (err) {
            deticStatus.textContent = "Error: " + err;
            deticStatus.style.color = "#f87171";
          }
        };
      }

      if (deticListBtn && deticListOut && deticStatus) {
        deticListBtn.onclick = async () => {
          deticStatus.textContent = "Listing Detic detections...";
          deticStatus.style.color = "#9ca3af";
          try {
            const res = await fetch(`${BACKEND_REST_URL}/list_detics`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: "{}",
            });
            const data = await res.json();
            deticListOut.textContent = JSON.stringify(data.detections ?? data, null, 2);
            deticStatus.textContent = "Response: " + JSON.stringify(data);
            deticStatus.style.color = data.ok ? "#9ca3af" : "#f87171";
          } catch (err) {
            deticStatus.textContent = "Error: " + err;
            deticStatus.style.color = "#f87171";
          }
        };
      }
    }

    // init
    syncUI();
    connectState();
    connectVideo();
    sendCommand();
    showTab("map");
  </script>
</body>
</html>
